Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    COMMA
    DIVIDE
    ELSE
    EXP
    NEQ
    PRINT
    STRING

Grammar

Rule 0     S' -> program
Rule 1     program -> function
Rule 2     function -> INT ID LPAREN RPAREN LBRACE block RETURN NUMBER SEMICOLON RBRACE
Rule 3     block -> block statement
Rule 4     block -> empty
Rule 5     statement -> INT ID EQUAL expression SEMICOLON
Rule 6     statement -> BOOL ID EQUAL expression SEMICOLON
Rule 7     statement -> ID EQUAL expression SEMICOLON
Rule 8     statement -> IF LPAREN logical_a RPAREN LBRACE block RBRACE
Rule 9     logical_a -> logical_a OR logical_b
Rule 10    logical_a -> logical_b
Rule 11    logical_b -> logical_b AND logical_c
Rule 12    logical_b -> logical_c
Rule 13    logical_c -> logical_c EQ logical_d
Rule 14    logical_c -> logical_d
Rule 15    logical_d -> logical_d LE expression
Rule 16    logical_d -> logical_d GE expression
Rule 17    logical_d -> logical_d LT expression
Rule 18    logical_d -> logical_d GT expression
Rule 19    logical_d -> expression
Rule 20    expression -> expression PLUS term
Rule 21    expression -> expression MINUS term
Rule 22    expression -> term
Rule 23    term -> term TIMES factor
Rule 24    term -> factor
Rule 25    factor -> NUMBER
Rule 26    factor -> TRUE
Rule 27    factor -> FALSE
Rule 28    factor -> ID
Rule 29    factor -> LPAREN logical_a RPAREN
Rule 30    empty -> <empty>

Terminals, with rules where they appear

AND                  : 11
BOOL                 : 6
COMMA                : 
DIVIDE               : 
ELSE                 : 
EQ                   : 13
EQUAL                : 5 6 7
EXP                  : 
FALSE                : 27
GE                   : 16
GT                   : 18
ID                   : 2 5 6 7 28
IF                   : 8
INT                  : 2 5
LBRACE               : 2 8
LE                   : 15
LPAREN               : 2 8 29
LT                   : 17
MINUS                : 21
NEQ                  : 
NUMBER               : 2 25
OR                   : 9
PLUS                 : 20
PRINT                : 
RBRACE               : 2 8
RETURN               : 2
RPAREN               : 2 8 29
SEMICOLON            : 2 5 6 7
STRING               : 
TIMES                : 23
TRUE                 : 26
error                : 

Nonterminals, with rules where they appear

block                : 2 3 8
empty                : 4
expression           : 5 6 7 15 16 17 18 19 20 21
factor               : 23 24
function             : 1
logical_a            : 8 9 29
logical_b            : 9 10 11
logical_c            : 11 12 13
logical_d            : 13 14 15 16 17 18
program              : 0
statement            : 3
term                 : 20 21 22 23

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . function
    (2) function -> . INT ID LPAREN RPAREN LBRACE block RETURN NUMBER SEMICOLON RBRACE

    INT             shift and go to state 3

    program                        shift and go to state 1
    function                       shift and go to state 2

state 1

    (0) S' -> program .



state 2

    (1) program -> function .

    $end            reduce using rule 1 (program -> function .)


state 3

    (2) function -> INT . ID LPAREN RPAREN LBRACE block RETURN NUMBER SEMICOLON RBRACE

    ID              shift and go to state 4


state 4

    (2) function -> INT ID . LPAREN RPAREN LBRACE block RETURN NUMBER SEMICOLON RBRACE

    LPAREN          shift and go to state 5


state 5

    (2) function -> INT ID LPAREN . RPAREN LBRACE block RETURN NUMBER SEMICOLON RBRACE

    RPAREN          shift and go to state 6


state 6

    (2) function -> INT ID LPAREN RPAREN . LBRACE block RETURN NUMBER SEMICOLON RBRACE

    LBRACE          shift and go to state 7


state 7

    (2) function -> INT ID LPAREN RPAREN LBRACE . block RETURN NUMBER SEMICOLON RBRACE
    (3) block -> . block statement
    (4) block -> . empty
    (30) empty -> .

    RETURN          reduce using rule 30 (empty -> .)
    INT             reduce using rule 30 (empty -> .)
    BOOL            reduce using rule 30 (empty -> .)
    ID              reduce using rule 30 (empty -> .)
    IF              reduce using rule 30 (empty -> .)

    block                          shift and go to state 8
    empty                          shift and go to state 9

state 8

    (2) function -> INT ID LPAREN RPAREN LBRACE block . RETURN NUMBER SEMICOLON RBRACE
    (3) block -> block . statement
    (5) statement -> . INT ID EQUAL expression SEMICOLON
    (6) statement -> . BOOL ID EQUAL expression SEMICOLON
    (7) statement -> . ID EQUAL expression SEMICOLON
    (8) statement -> . IF LPAREN logical_a RPAREN LBRACE block RBRACE

    RETURN          shift and go to state 12
    INT             shift and go to state 10
    BOOL            shift and go to state 14
    ID              shift and go to state 11
    IF              shift and go to state 15

    statement                      shift and go to state 13

state 9

    (4) block -> empty .

    RETURN          reduce using rule 4 (block -> empty .)
    INT             reduce using rule 4 (block -> empty .)
    BOOL            reduce using rule 4 (block -> empty .)
    ID              reduce using rule 4 (block -> empty .)
    IF              reduce using rule 4 (block -> empty .)
    RBRACE          reduce using rule 4 (block -> empty .)


state 10

    (5) statement -> INT . ID EQUAL expression SEMICOLON

    ID              shift and go to state 16


state 11

    (7) statement -> ID . EQUAL expression SEMICOLON

    EQUAL           shift and go to state 17


state 12

    (2) function -> INT ID LPAREN RPAREN LBRACE block RETURN . NUMBER SEMICOLON RBRACE

    NUMBER          shift and go to state 18


state 13

    (3) block -> block statement .

    RETURN          reduce using rule 3 (block -> block statement .)
    INT             reduce using rule 3 (block -> block statement .)
    BOOL            reduce using rule 3 (block -> block statement .)
    ID              reduce using rule 3 (block -> block statement .)
    IF              reduce using rule 3 (block -> block statement .)
    RBRACE          reduce using rule 3 (block -> block statement .)


state 14

    (6) statement -> BOOL . ID EQUAL expression SEMICOLON

    ID              shift and go to state 19


state 15

    (8) statement -> IF . LPAREN logical_a RPAREN LBRACE block RBRACE

    LPAREN          shift and go to state 20


state 16

    (5) statement -> INT ID . EQUAL expression SEMICOLON

    EQUAL           shift and go to state 21


state 17

    (7) statement -> ID EQUAL . expression SEMICOLON
    (20) expression -> . expression PLUS term
    (21) expression -> . expression MINUS term
    (22) expression -> . term
    (23) term -> . term TIMES factor
    (24) term -> . factor
    (25) factor -> . NUMBER
    (26) factor -> . TRUE
    (27) factor -> . FALSE
    (28) factor -> . ID
    (29) factor -> . LPAREN logical_a RPAREN

    NUMBER          shift and go to state 26
    TRUE            shift and go to state 27
    FALSE           shift and go to state 28
    ID              shift and go to state 22
    LPAREN          shift and go to state 29

    expression                     shift and go to state 23
    term                           shift and go to state 24
    factor                         shift and go to state 25

state 18

    (2) function -> INT ID LPAREN RPAREN LBRACE block RETURN NUMBER . SEMICOLON RBRACE

    SEMICOLON       shift and go to state 30


state 19

    (6) statement -> BOOL ID . EQUAL expression SEMICOLON

    EQUAL           shift and go to state 31


state 20

    (8) statement -> IF LPAREN . logical_a RPAREN LBRACE block RBRACE
    (9) logical_a -> . logical_a OR logical_b
    (10) logical_a -> . logical_b
    (11) logical_b -> . logical_b AND logical_c
    (12) logical_b -> . logical_c
    (13) logical_c -> . logical_c EQ logical_d
    (14) logical_c -> . logical_d
    (15) logical_d -> . logical_d LE expression
    (16) logical_d -> . logical_d GE expression
    (17) logical_d -> . logical_d LT expression
    (18) logical_d -> . logical_d GT expression
    (19) logical_d -> . expression
    (20) expression -> . expression PLUS term
    (21) expression -> . expression MINUS term
    (22) expression -> . term
    (23) term -> . term TIMES factor
    (24) term -> . factor
    (25) factor -> . NUMBER
    (26) factor -> . TRUE
    (27) factor -> . FALSE
    (28) factor -> . ID
    (29) factor -> . LPAREN logical_a RPAREN

    NUMBER          shift and go to state 26
    TRUE            shift and go to state 27
    FALSE           shift and go to state 28
    ID              shift and go to state 22
    LPAREN          shift and go to state 29

    logical_a                      shift and go to state 32
    logical_b                      shift and go to state 33
    logical_c                      shift and go to state 34
    logical_d                      shift and go to state 35
    expression                     shift and go to state 36
    term                           shift and go to state 24
    factor                         shift and go to state 25

state 21

    (5) statement -> INT ID EQUAL . expression SEMICOLON
    (20) expression -> . expression PLUS term
    (21) expression -> . expression MINUS term
    (22) expression -> . term
    (23) term -> . term TIMES factor
    (24) term -> . factor
    (25) factor -> . NUMBER
    (26) factor -> . TRUE
    (27) factor -> . FALSE
    (28) factor -> . ID
    (29) factor -> . LPAREN logical_a RPAREN

    NUMBER          shift and go to state 26
    TRUE            shift and go to state 27
    FALSE           shift and go to state 28
    ID              shift and go to state 22
    LPAREN          shift and go to state 29

    expression                     shift and go to state 37
    term                           shift and go to state 24
    factor                         shift and go to state 25

state 22

    (28) factor -> ID .

    TIMES           reduce using rule 28 (factor -> ID .)
    SEMICOLON       reduce using rule 28 (factor -> ID .)
    PLUS            reduce using rule 28 (factor -> ID .)
    MINUS           reduce using rule 28 (factor -> ID .)
    LE              reduce using rule 28 (factor -> ID .)
    GE              reduce using rule 28 (factor -> ID .)
    LT              reduce using rule 28 (factor -> ID .)
    GT              reduce using rule 28 (factor -> ID .)
    EQ              reduce using rule 28 (factor -> ID .)
    AND             reduce using rule 28 (factor -> ID .)
    RPAREN          reduce using rule 28 (factor -> ID .)
    OR              reduce using rule 28 (factor -> ID .)


state 23

    (7) statement -> ID EQUAL expression . SEMICOLON
    (20) expression -> expression . PLUS term
    (21) expression -> expression . MINUS term

    SEMICOLON       shift and go to state 38
    PLUS            shift and go to state 39
    MINUS           shift and go to state 40


state 24

    (22) expression -> term .
    (23) term -> term . TIMES factor

    SEMICOLON       reduce using rule 22 (expression -> term .)
    PLUS            reduce using rule 22 (expression -> term .)
    MINUS           reduce using rule 22 (expression -> term .)
    LE              reduce using rule 22 (expression -> term .)
    GE              reduce using rule 22 (expression -> term .)
    LT              reduce using rule 22 (expression -> term .)
    GT              reduce using rule 22 (expression -> term .)
    EQ              reduce using rule 22 (expression -> term .)
    AND             reduce using rule 22 (expression -> term .)
    RPAREN          reduce using rule 22 (expression -> term .)
    OR              reduce using rule 22 (expression -> term .)
    TIMES           shift and go to state 41


state 25

    (24) term -> factor .

    TIMES           reduce using rule 24 (term -> factor .)
    SEMICOLON       reduce using rule 24 (term -> factor .)
    PLUS            reduce using rule 24 (term -> factor .)
    MINUS           reduce using rule 24 (term -> factor .)
    LE              reduce using rule 24 (term -> factor .)
    GE              reduce using rule 24 (term -> factor .)
    LT              reduce using rule 24 (term -> factor .)
    GT              reduce using rule 24 (term -> factor .)
    EQ              reduce using rule 24 (term -> factor .)
    AND             reduce using rule 24 (term -> factor .)
    RPAREN          reduce using rule 24 (term -> factor .)
    OR              reduce using rule 24 (term -> factor .)


state 26

    (25) factor -> NUMBER .

    TIMES           reduce using rule 25 (factor -> NUMBER .)
    SEMICOLON       reduce using rule 25 (factor -> NUMBER .)
    PLUS            reduce using rule 25 (factor -> NUMBER .)
    MINUS           reduce using rule 25 (factor -> NUMBER .)
    LE              reduce using rule 25 (factor -> NUMBER .)
    GE              reduce using rule 25 (factor -> NUMBER .)
    LT              reduce using rule 25 (factor -> NUMBER .)
    GT              reduce using rule 25 (factor -> NUMBER .)
    EQ              reduce using rule 25 (factor -> NUMBER .)
    AND             reduce using rule 25 (factor -> NUMBER .)
    RPAREN          reduce using rule 25 (factor -> NUMBER .)
    OR              reduce using rule 25 (factor -> NUMBER .)


state 27

    (26) factor -> TRUE .

    TIMES           reduce using rule 26 (factor -> TRUE .)
    SEMICOLON       reduce using rule 26 (factor -> TRUE .)
    PLUS            reduce using rule 26 (factor -> TRUE .)
    MINUS           reduce using rule 26 (factor -> TRUE .)
    LE              reduce using rule 26 (factor -> TRUE .)
    GE              reduce using rule 26 (factor -> TRUE .)
    LT              reduce using rule 26 (factor -> TRUE .)
    GT              reduce using rule 26 (factor -> TRUE .)
    EQ              reduce using rule 26 (factor -> TRUE .)
    AND             reduce using rule 26 (factor -> TRUE .)
    RPAREN          reduce using rule 26 (factor -> TRUE .)
    OR              reduce using rule 26 (factor -> TRUE .)


state 28

    (27) factor -> FALSE .

    TIMES           reduce using rule 27 (factor -> FALSE .)
    SEMICOLON       reduce using rule 27 (factor -> FALSE .)
    PLUS            reduce using rule 27 (factor -> FALSE .)
    MINUS           reduce using rule 27 (factor -> FALSE .)
    LE              reduce using rule 27 (factor -> FALSE .)
    GE              reduce using rule 27 (factor -> FALSE .)
    LT              reduce using rule 27 (factor -> FALSE .)
    GT              reduce using rule 27 (factor -> FALSE .)
    EQ              reduce using rule 27 (factor -> FALSE .)
    AND             reduce using rule 27 (factor -> FALSE .)
    RPAREN          reduce using rule 27 (factor -> FALSE .)
    OR              reduce using rule 27 (factor -> FALSE .)


state 29

    (29) factor -> LPAREN . logical_a RPAREN
    (9) logical_a -> . logical_a OR logical_b
    (10) logical_a -> . logical_b
    (11) logical_b -> . logical_b AND logical_c
    (12) logical_b -> . logical_c
    (13) logical_c -> . logical_c EQ logical_d
    (14) logical_c -> . logical_d
    (15) logical_d -> . logical_d LE expression
    (16) logical_d -> . logical_d GE expression
    (17) logical_d -> . logical_d LT expression
    (18) logical_d -> . logical_d GT expression
    (19) logical_d -> . expression
    (20) expression -> . expression PLUS term
    (21) expression -> . expression MINUS term
    (22) expression -> . term
    (23) term -> . term TIMES factor
    (24) term -> . factor
    (25) factor -> . NUMBER
    (26) factor -> . TRUE
    (27) factor -> . FALSE
    (28) factor -> . ID
    (29) factor -> . LPAREN logical_a RPAREN

    NUMBER          shift and go to state 26
    TRUE            shift and go to state 27
    FALSE           shift and go to state 28
    ID              shift and go to state 22
    LPAREN          shift and go to state 29

    logical_a                      shift and go to state 42
    logical_b                      shift and go to state 33
    logical_c                      shift and go to state 34
    logical_d                      shift and go to state 35
    expression                     shift and go to state 36
    term                           shift and go to state 24
    factor                         shift and go to state 25

state 30

    (2) function -> INT ID LPAREN RPAREN LBRACE block RETURN NUMBER SEMICOLON . RBRACE

    RBRACE          shift and go to state 43


state 31

    (6) statement -> BOOL ID EQUAL . expression SEMICOLON
    (20) expression -> . expression PLUS term
    (21) expression -> . expression MINUS term
    (22) expression -> . term
    (23) term -> . term TIMES factor
    (24) term -> . factor
    (25) factor -> . NUMBER
    (26) factor -> . TRUE
    (27) factor -> . FALSE
    (28) factor -> . ID
    (29) factor -> . LPAREN logical_a RPAREN

    NUMBER          shift and go to state 26
    TRUE            shift and go to state 27
    FALSE           shift and go to state 28
    ID              shift and go to state 22
    LPAREN          shift and go to state 29

    expression                     shift and go to state 44
    term                           shift and go to state 24
    factor                         shift and go to state 25

state 32

    (8) statement -> IF LPAREN logical_a . RPAREN LBRACE block RBRACE
    (9) logical_a -> logical_a . OR logical_b

    RPAREN          shift and go to state 45
    OR              shift and go to state 46


state 33

    (10) logical_a -> logical_b .
    (11) logical_b -> logical_b . AND logical_c

    RPAREN          reduce using rule 10 (logical_a -> logical_b .)
    OR              reduce using rule 10 (logical_a -> logical_b .)
    AND             shift and go to state 47


state 34

    (12) logical_b -> logical_c .
    (13) logical_c -> logical_c . EQ logical_d

    AND             reduce using rule 12 (logical_b -> logical_c .)
    RPAREN          reduce using rule 12 (logical_b -> logical_c .)
    OR              reduce using rule 12 (logical_b -> logical_c .)
    EQ              shift and go to state 48


state 35

    (14) logical_c -> logical_d .
    (15) logical_d -> logical_d . LE expression
    (16) logical_d -> logical_d . GE expression
    (17) logical_d -> logical_d . LT expression
    (18) logical_d -> logical_d . GT expression

    EQ              reduce using rule 14 (logical_c -> logical_d .)
    AND             reduce using rule 14 (logical_c -> logical_d .)
    RPAREN          reduce using rule 14 (logical_c -> logical_d .)
    OR              reduce using rule 14 (logical_c -> logical_d .)
    LE              shift and go to state 49
    GE              shift and go to state 50
    LT              shift and go to state 51
    GT              shift and go to state 52


state 36

    (19) logical_d -> expression .
    (20) expression -> expression . PLUS term
    (21) expression -> expression . MINUS term

    LE              reduce using rule 19 (logical_d -> expression .)
    GE              reduce using rule 19 (logical_d -> expression .)
    LT              reduce using rule 19 (logical_d -> expression .)
    GT              reduce using rule 19 (logical_d -> expression .)
    EQ              reduce using rule 19 (logical_d -> expression .)
    AND             reduce using rule 19 (logical_d -> expression .)
    RPAREN          reduce using rule 19 (logical_d -> expression .)
    OR              reduce using rule 19 (logical_d -> expression .)
    PLUS            shift and go to state 39
    MINUS           shift and go to state 40


state 37

    (5) statement -> INT ID EQUAL expression . SEMICOLON
    (20) expression -> expression . PLUS term
    (21) expression -> expression . MINUS term

    SEMICOLON       shift and go to state 53
    PLUS            shift and go to state 39
    MINUS           shift and go to state 40


state 38

    (7) statement -> ID EQUAL expression SEMICOLON .

    RETURN          reduce using rule 7 (statement -> ID EQUAL expression SEMICOLON .)
    INT             reduce using rule 7 (statement -> ID EQUAL expression SEMICOLON .)
    BOOL            reduce using rule 7 (statement -> ID EQUAL expression SEMICOLON .)
    ID              reduce using rule 7 (statement -> ID EQUAL expression SEMICOLON .)
    IF              reduce using rule 7 (statement -> ID EQUAL expression SEMICOLON .)
    RBRACE          reduce using rule 7 (statement -> ID EQUAL expression SEMICOLON .)


state 39

    (20) expression -> expression PLUS . term
    (23) term -> . term TIMES factor
    (24) term -> . factor
    (25) factor -> . NUMBER
    (26) factor -> . TRUE
    (27) factor -> . FALSE
    (28) factor -> . ID
    (29) factor -> . LPAREN logical_a RPAREN

    NUMBER          shift and go to state 26
    TRUE            shift and go to state 27
    FALSE           shift and go to state 28
    ID              shift and go to state 22
    LPAREN          shift and go to state 29

    term                           shift and go to state 54
    factor                         shift and go to state 25

state 40

    (21) expression -> expression MINUS . term
    (23) term -> . term TIMES factor
    (24) term -> . factor
    (25) factor -> . NUMBER
    (26) factor -> . TRUE
    (27) factor -> . FALSE
    (28) factor -> . ID
    (29) factor -> . LPAREN logical_a RPAREN

    NUMBER          shift and go to state 26
    TRUE            shift and go to state 27
    FALSE           shift and go to state 28
    ID              shift and go to state 22
    LPAREN          shift and go to state 29

    term                           shift and go to state 55
    factor                         shift and go to state 25

state 41

    (23) term -> term TIMES . factor
    (25) factor -> . NUMBER
    (26) factor -> . TRUE
    (27) factor -> . FALSE
    (28) factor -> . ID
    (29) factor -> . LPAREN logical_a RPAREN

    NUMBER          shift and go to state 26
    TRUE            shift and go to state 27
    FALSE           shift and go to state 28
    ID              shift and go to state 22
    LPAREN          shift and go to state 29

    factor                         shift and go to state 56

state 42

    (29) factor -> LPAREN logical_a . RPAREN
    (9) logical_a -> logical_a . OR logical_b

    RPAREN          shift and go to state 57
    OR              shift and go to state 46


state 43

    (2) function -> INT ID LPAREN RPAREN LBRACE block RETURN NUMBER SEMICOLON RBRACE .

    $end            reduce using rule 2 (function -> INT ID LPAREN RPAREN LBRACE block RETURN NUMBER SEMICOLON RBRACE .)


state 44

    (6) statement -> BOOL ID EQUAL expression . SEMICOLON
    (20) expression -> expression . PLUS term
    (21) expression -> expression . MINUS term

    SEMICOLON       shift and go to state 58
    PLUS            shift and go to state 39
    MINUS           shift and go to state 40


state 45

    (8) statement -> IF LPAREN logical_a RPAREN . LBRACE block RBRACE

    LBRACE          shift and go to state 59


state 46

    (9) logical_a -> logical_a OR . logical_b
    (11) logical_b -> . logical_b AND logical_c
    (12) logical_b -> . logical_c
    (13) logical_c -> . logical_c EQ logical_d
    (14) logical_c -> . logical_d
    (15) logical_d -> . logical_d LE expression
    (16) logical_d -> . logical_d GE expression
    (17) logical_d -> . logical_d LT expression
    (18) logical_d -> . logical_d GT expression
    (19) logical_d -> . expression
    (20) expression -> . expression PLUS term
    (21) expression -> . expression MINUS term
    (22) expression -> . term
    (23) term -> . term TIMES factor
    (24) term -> . factor
    (25) factor -> . NUMBER
    (26) factor -> . TRUE
    (27) factor -> . FALSE
    (28) factor -> . ID
    (29) factor -> . LPAREN logical_a RPAREN

    NUMBER          shift and go to state 26
    TRUE            shift and go to state 27
    FALSE           shift and go to state 28
    ID              shift and go to state 22
    LPAREN          shift and go to state 29

    logical_b                      shift and go to state 60
    logical_c                      shift and go to state 34
    logical_d                      shift and go to state 35
    expression                     shift and go to state 36
    term                           shift and go to state 24
    factor                         shift and go to state 25

state 47

    (11) logical_b -> logical_b AND . logical_c
    (13) logical_c -> . logical_c EQ logical_d
    (14) logical_c -> . logical_d
    (15) logical_d -> . logical_d LE expression
    (16) logical_d -> . logical_d GE expression
    (17) logical_d -> . logical_d LT expression
    (18) logical_d -> . logical_d GT expression
    (19) logical_d -> . expression
    (20) expression -> . expression PLUS term
    (21) expression -> . expression MINUS term
    (22) expression -> . term
    (23) term -> . term TIMES factor
    (24) term -> . factor
    (25) factor -> . NUMBER
    (26) factor -> . TRUE
    (27) factor -> . FALSE
    (28) factor -> . ID
    (29) factor -> . LPAREN logical_a RPAREN

    NUMBER          shift and go to state 26
    TRUE            shift and go to state 27
    FALSE           shift and go to state 28
    ID              shift and go to state 22
    LPAREN          shift and go to state 29

    logical_c                      shift and go to state 61
    logical_d                      shift and go to state 35
    expression                     shift and go to state 36
    term                           shift and go to state 24
    factor                         shift and go to state 25

state 48

    (13) logical_c -> logical_c EQ . logical_d
    (15) logical_d -> . logical_d LE expression
    (16) logical_d -> . logical_d GE expression
    (17) logical_d -> . logical_d LT expression
    (18) logical_d -> . logical_d GT expression
    (19) logical_d -> . expression
    (20) expression -> . expression PLUS term
    (21) expression -> . expression MINUS term
    (22) expression -> . term
    (23) term -> . term TIMES factor
    (24) term -> . factor
    (25) factor -> . NUMBER
    (26) factor -> . TRUE
    (27) factor -> . FALSE
    (28) factor -> . ID
    (29) factor -> . LPAREN logical_a RPAREN

    NUMBER          shift and go to state 26
    TRUE            shift and go to state 27
    FALSE           shift and go to state 28
    ID              shift and go to state 22
    LPAREN          shift and go to state 29

    logical_d                      shift and go to state 62
    expression                     shift and go to state 36
    term                           shift and go to state 24
    factor                         shift and go to state 25

state 49

    (15) logical_d -> logical_d LE . expression
    (20) expression -> . expression PLUS term
    (21) expression -> . expression MINUS term
    (22) expression -> . term
    (23) term -> . term TIMES factor
    (24) term -> . factor
    (25) factor -> . NUMBER
    (26) factor -> . TRUE
    (27) factor -> . FALSE
    (28) factor -> . ID
    (29) factor -> . LPAREN logical_a RPAREN

    NUMBER          shift and go to state 26
    TRUE            shift and go to state 27
    FALSE           shift and go to state 28
    ID              shift and go to state 22
    LPAREN          shift and go to state 29

    expression                     shift and go to state 63
    term                           shift and go to state 24
    factor                         shift and go to state 25

state 50

    (16) logical_d -> logical_d GE . expression
    (20) expression -> . expression PLUS term
    (21) expression -> . expression MINUS term
    (22) expression -> . term
    (23) term -> . term TIMES factor
    (24) term -> . factor
    (25) factor -> . NUMBER
    (26) factor -> . TRUE
    (27) factor -> . FALSE
    (28) factor -> . ID
    (29) factor -> . LPAREN logical_a RPAREN

    NUMBER          shift and go to state 26
    TRUE            shift and go to state 27
    FALSE           shift and go to state 28
    ID              shift and go to state 22
    LPAREN          shift and go to state 29

    expression                     shift and go to state 64
    term                           shift and go to state 24
    factor                         shift and go to state 25

state 51

    (17) logical_d -> logical_d LT . expression
    (20) expression -> . expression PLUS term
    (21) expression -> . expression MINUS term
    (22) expression -> . term
    (23) term -> . term TIMES factor
    (24) term -> . factor
    (25) factor -> . NUMBER
    (26) factor -> . TRUE
    (27) factor -> . FALSE
    (28) factor -> . ID
    (29) factor -> . LPAREN logical_a RPAREN

    NUMBER          shift and go to state 26
    TRUE            shift and go to state 27
    FALSE           shift and go to state 28
    ID              shift and go to state 22
    LPAREN          shift and go to state 29

    expression                     shift and go to state 65
    term                           shift and go to state 24
    factor                         shift and go to state 25

state 52

    (18) logical_d -> logical_d GT . expression
    (20) expression -> . expression PLUS term
    (21) expression -> . expression MINUS term
    (22) expression -> . term
    (23) term -> . term TIMES factor
    (24) term -> . factor
    (25) factor -> . NUMBER
    (26) factor -> . TRUE
    (27) factor -> . FALSE
    (28) factor -> . ID
    (29) factor -> . LPAREN logical_a RPAREN

    NUMBER          shift and go to state 26
    TRUE            shift and go to state 27
    FALSE           shift and go to state 28
    ID              shift and go to state 22
    LPAREN          shift and go to state 29

    expression                     shift and go to state 66
    term                           shift and go to state 24
    factor                         shift and go to state 25

state 53

    (5) statement -> INT ID EQUAL expression SEMICOLON .

    RETURN          reduce using rule 5 (statement -> INT ID EQUAL expression SEMICOLON .)
    INT             reduce using rule 5 (statement -> INT ID EQUAL expression SEMICOLON .)
    BOOL            reduce using rule 5 (statement -> INT ID EQUAL expression SEMICOLON .)
    ID              reduce using rule 5 (statement -> INT ID EQUAL expression SEMICOLON .)
    IF              reduce using rule 5 (statement -> INT ID EQUAL expression SEMICOLON .)
    RBRACE          reduce using rule 5 (statement -> INT ID EQUAL expression SEMICOLON .)


state 54

    (20) expression -> expression PLUS term .
    (23) term -> term . TIMES factor

    SEMICOLON       reduce using rule 20 (expression -> expression PLUS term .)
    PLUS            reduce using rule 20 (expression -> expression PLUS term .)
    MINUS           reduce using rule 20 (expression -> expression PLUS term .)
    LE              reduce using rule 20 (expression -> expression PLUS term .)
    GE              reduce using rule 20 (expression -> expression PLUS term .)
    LT              reduce using rule 20 (expression -> expression PLUS term .)
    GT              reduce using rule 20 (expression -> expression PLUS term .)
    EQ              reduce using rule 20 (expression -> expression PLUS term .)
    AND             reduce using rule 20 (expression -> expression PLUS term .)
    RPAREN          reduce using rule 20 (expression -> expression PLUS term .)
    OR              reduce using rule 20 (expression -> expression PLUS term .)
    TIMES           shift and go to state 41


state 55

    (21) expression -> expression MINUS term .
    (23) term -> term . TIMES factor

    SEMICOLON       reduce using rule 21 (expression -> expression MINUS term .)
    PLUS            reduce using rule 21 (expression -> expression MINUS term .)
    MINUS           reduce using rule 21 (expression -> expression MINUS term .)
    LE              reduce using rule 21 (expression -> expression MINUS term .)
    GE              reduce using rule 21 (expression -> expression MINUS term .)
    LT              reduce using rule 21 (expression -> expression MINUS term .)
    GT              reduce using rule 21 (expression -> expression MINUS term .)
    EQ              reduce using rule 21 (expression -> expression MINUS term .)
    AND             reduce using rule 21 (expression -> expression MINUS term .)
    RPAREN          reduce using rule 21 (expression -> expression MINUS term .)
    OR              reduce using rule 21 (expression -> expression MINUS term .)
    TIMES           shift and go to state 41


state 56

    (23) term -> term TIMES factor .

    TIMES           reduce using rule 23 (term -> term TIMES factor .)
    SEMICOLON       reduce using rule 23 (term -> term TIMES factor .)
    PLUS            reduce using rule 23 (term -> term TIMES factor .)
    MINUS           reduce using rule 23 (term -> term TIMES factor .)
    LE              reduce using rule 23 (term -> term TIMES factor .)
    GE              reduce using rule 23 (term -> term TIMES factor .)
    LT              reduce using rule 23 (term -> term TIMES factor .)
    GT              reduce using rule 23 (term -> term TIMES factor .)
    EQ              reduce using rule 23 (term -> term TIMES factor .)
    AND             reduce using rule 23 (term -> term TIMES factor .)
    RPAREN          reduce using rule 23 (term -> term TIMES factor .)
    OR              reduce using rule 23 (term -> term TIMES factor .)


state 57

    (29) factor -> LPAREN logical_a RPAREN .

    TIMES           reduce using rule 29 (factor -> LPAREN logical_a RPAREN .)
    SEMICOLON       reduce using rule 29 (factor -> LPAREN logical_a RPAREN .)
    PLUS            reduce using rule 29 (factor -> LPAREN logical_a RPAREN .)
    MINUS           reduce using rule 29 (factor -> LPAREN logical_a RPAREN .)
    LE              reduce using rule 29 (factor -> LPAREN logical_a RPAREN .)
    GE              reduce using rule 29 (factor -> LPAREN logical_a RPAREN .)
    LT              reduce using rule 29 (factor -> LPAREN logical_a RPAREN .)
    GT              reduce using rule 29 (factor -> LPAREN logical_a RPAREN .)
    EQ              reduce using rule 29 (factor -> LPAREN logical_a RPAREN .)
    AND             reduce using rule 29 (factor -> LPAREN logical_a RPAREN .)
    RPAREN          reduce using rule 29 (factor -> LPAREN logical_a RPAREN .)
    OR              reduce using rule 29 (factor -> LPAREN logical_a RPAREN .)


state 58

    (6) statement -> BOOL ID EQUAL expression SEMICOLON .

    RETURN          reduce using rule 6 (statement -> BOOL ID EQUAL expression SEMICOLON .)
    INT             reduce using rule 6 (statement -> BOOL ID EQUAL expression SEMICOLON .)
    BOOL            reduce using rule 6 (statement -> BOOL ID EQUAL expression SEMICOLON .)
    ID              reduce using rule 6 (statement -> BOOL ID EQUAL expression SEMICOLON .)
    IF              reduce using rule 6 (statement -> BOOL ID EQUAL expression SEMICOLON .)
    RBRACE          reduce using rule 6 (statement -> BOOL ID EQUAL expression SEMICOLON .)


state 59

    (8) statement -> IF LPAREN logical_a RPAREN LBRACE . block RBRACE
    (3) block -> . block statement
    (4) block -> . empty
    (30) empty -> .

    RBRACE          reduce using rule 30 (empty -> .)
    INT             reduce using rule 30 (empty -> .)
    BOOL            reduce using rule 30 (empty -> .)
    ID              reduce using rule 30 (empty -> .)
    IF              reduce using rule 30 (empty -> .)

    block                          shift and go to state 67
    empty                          shift and go to state 9

state 60

    (9) logical_a -> logical_a OR logical_b .
    (11) logical_b -> logical_b . AND logical_c

    RPAREN          reduce using rule 9 (logical_a -> logical_a OR logical_b .)
    OR              reduce using rule 9 (logical_a -> logical_a OR logical_b .)
    AND             shift and go to state 47


state 61

    (11) logical_b -> logical_b AND logical_c .
    (13) logical_c -> logical_c . EQ logical_d

    AND             reduce using rule 11 (logical_b -> logical_b AND logical_c .)
    RPAREN          reduce using rule 11 (logical_b -> logical_b AND logical_c .)
    OR              reduce using rule 11 (logical_b -> logical_b AND logical_c .)
    EQ              shift and go to state 48


state 62

    (13) logical_c -> logical_c EQ logical_d .
    (15) logical_d -> logical_d . LE expression
    (16) logical_d -> logical_d . GE expression
    (17) logical_d -> logical_d . LT expression
    (18) logical_d -> logical_d . GT expression

    EQ              reduce using rule 13 (logical_c -> logical_c EQ logical_d .)
    AND             reduce using rule 13 (logical_c -> logical_c EQ logical_d .)
    RPAREN          reduce using rule 13 (logical_c -> logical_c EQ logical_d .)
    OR              reduce using rule 13 (logical_c -> logical_c EQ logical_d .)
    LE              shift and go to state 49
    GE              shift and go to state 50
    LT              shift and go to state 51
    GT              shift and go to state 52


state 63

    (15) logical_d -> logical_d LE expression .
    (20) expression -> expression . PLUS term
    (21) expression -> expression . MINUS term

    LE              reduce using rule 15 (logical_d -> logical_d LE expression .)
    GE              reduce using rule 15 (logical_d -> logical_d LE expression .)
    LT              reduce using rule 15 (logical_d -> logical_d LE expression .)
    GT              reduce using rule 15 (logical_d -> logical_d LE expression .)
    EQ              reduce using rule 15 (logical_d -> logical_d LE expression .)
    AND             reduce using rule 15 (logical_d -> logical_d LE expression .)
    RPAREN          reduce using rule 15 (logical_d -> logical_d LE expression .)
    OR              reduce using rule 15 (logical_d -> logical_d LE expression .)
    PLUS            shift and go to state 39
    MINUS           shift and go to state 40


state 64

    (16) logical_d -> logical_d GE expression .
    (20) expression -> expression . PLUS term
    (21) expression -> expression . MINUS term

    LE              reduce using rule 16 (logical_d -> logical_d GE expression .)
    GE              reduce using rule 16 (logical_d -> logical_d GE expression .)
    LT              reduce using rule 16 (logical_d -> logical_d GE expression .)
    GT              reduce using rule 16 (logical_d -> logical_d GE expression .)
    EQ              reduce using rule 16 (logical_d -> logical_d GE expression .)
    AND             reduce using rule 16 (logical_d -> logical_d GE expression .)
    RPAREN          reduce using rule 16 (logical_d -> logical_d GE expression .)
    OR              reduce using rule 16 (logical_d -> logical_d GE expression .)
    PLUS            shift and go to state 39
    MINUS           shift and go to state 40


state 65

    (17) logical_d -> logical_d LT expression .
    (20) expression -> expression . PLUS term
    (21) expression -> expression . MINUS term

    LE              reduce using rule 17 (logical_d -> logical_d LT expression .)
    GE              reduce using rule 17 (logical_d -> logical_d LT expression .)
    LT              reduce using rule 17 (logical_d -> logical_d LT expression .)
    GT              reduce using rule 17 (logical_d -> logical_d LT expression .)
    EQ              reduce using rule 17 (logical_d -> logical_d LT expression .)
    AND             reduce using rule 17 (logical_d -> logical_d LT expression .)
    RPAREN          reduce using rule 17 (logical_d -> logical_d LT expression .)
    OR              reduce using rule 17 (logical_d -> logical_d LT expression .)
    PLUS            shift and go to state 39
    MINUS           shift and go to state 40


state 66

    (18) logical_d -> logical_d GT expression .
    (20) expression -> expression . PLUS term
    (21) expression -> expression . MINUS term

    LE              reduce using rule 18 (logical_d -> logical_d GT expression .)
    GE              reduce using rule 18 (logical_d -> logical_d GT expression .)
    LT              reduce using rule 18 (logical_d -> logical_d GT expression .)
    GT              reduce using rule 18 (logical_d -> logical_d GT expression .)
    EQ              reduce using rule 18 (logical_d -> logical_d GT expression .)
    AND             reduce using rule 18 (logical_d -> logical_d GT expression .)
    RPAREN          reduce using rule 18 (logical_d -> logical_d GT expression .)
    OR              reduce using rule 18 (logical_d -> logical_d GT expression .)
    PLUS            shift and go to state 39
    MINUS           shift and go to state 40


state 67

    (8) statement -> IF LPAREN logical_a RPAREN LBRACE block . RBRACE
    (3) block -> block . statement
    (5) statement -> . INT ID EQUAL expression SEMICOLON
    (6) statement -> . BOOL ID EQUAL expression SEMICOLON
    (7) statement -> . ID EQUAL expression SEMICOLON
    (8) statement -> . IF LPAREN logical_a RPAREN LBRACE block RBRACE

    RBRACE          shift and go to state 68
    INT             shift and go to state 10
    BOOL            shift and go to state 14
    ID              shift and go to state 11
    IF              shift and go to state 15

    statement                      shift and go to state 13

state 68

    (8) statement -> IF LPAREN logical_a RPAREN LBRACE block RBRACE .

    RETURN          reduce using rule 8 (statement -> IF LPAREN logical_a RPAREN LBRACE block RBRACE .)
    INT             reduce using rule 8 (statement -> IF LPAREN logical_a RPAREN LBRACE block RBRACE .)
    BOOL            reduce using rule 8 (statement -> IF LPAREN logical_a RPAREN LBRACE block RBRACE .)
    ID              reduce using rule 8 (statement -> IF LPAREN logical_a RPAREN LBRACE block RBRACE .)
    IF              reduce using rule 8 (statement -> IF LPAREN logical_a RPAREN LBRACE block RBRACE .)
    RBRACE          reduce using rule 8 (statement -> IF LPAREN logical_a RPAREN LBRACE block RBRACE .)

